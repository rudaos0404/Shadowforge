# Shadowforge - 기술 스택 및 개발 전략 정의서 (Team Ver.)

**프로젝트 개요:** 웹 기반 던전 탐험 전략 RPG

**목표:** 팀 협업 중심의 확장 가능한 아키텍처 구축 (Frontend-Backend 분리)

**최종 수정일:** 2026. 02. 02

---

## 1. System Architecture Overview

프로젝트는 **Client-Server 구조**로 분리하여 개발합니다.
Frontend와 Backend가 **REST API**를 통해 통신하며, 모든 코드는 **TypeScript**로 통일하여 언어 장벽을 없애고 생산성을 높입니다.

[Architecture Flow]
```
User <--> React Client <--(REST API/JWT)--> NestJS Server <--(Prisma)--> PostgreSQL
                                                ^
                                                |
                                          [Google Auth]
```

---

## 2. Frontend (Web Client)

**역할:** UI 렌더링, 애니메이션 연출, 즉각적인 사용자 상호작용 처리.

### 2.1 Core Stack
- **Language:** **TypeScript**
  - *이유:* 정적 타입 지정을 통해 런타임 오류 방지 및 팀원 간 코드 가독성 향상.
- **Framework:** **React (v18+)**
- **Build Tool:** **Vite**
- **Styling:** **Tailwind CSS**
  - *전략:* 유틸리티 클래스 기반으로 빠르게 UI를 구성하고, 모바일/PC 반응형 디자인 적용.
- **Animation:** **Framer Motion**
  - *용도:* 몬스터 피격(Shake), 체력 바 감소, 데미지 폰트, 화면 전환 등 연출 담당.

### 2.2 State Management (Hybrid Strategy)
데이터의 성격에 따라 관리 주체를 나눕니다.

| 구분 | 도구 | 관리 데이터 | 설명 |
| :--- | :--- | :--- | :--- |
| **Global** | **Zustand** | 플레이어 스탯, 골드, 인벤토리, JWT 토큰 | 앱 전역에서 유지되어야 하는 데이터 |
| **Local** | **useState** | 몬스터 HP, 전투 로그, 애니메이션 상태 | 화면이 바뀌면 초기화되어야 하는 일회성 데이터 |
| **Server** | **React Query** | 랭킹 리스트, 저장된 슬롯 정보 | 서버(DB)에서 가져오는 비동기 데이터 캐싱 |

---

## 3. Backend (API Server)

**역할:** 사용자 인증, 게임 결과 검증, 데이터 저장(DB), 랭킹 산출.

### 3.1 Core Stack
- **Framework:** **NestJS**
  - *이유:* 모듈(Module) 기반 구조로 역할 분담이 명확하며, Spring Boot와 유사한 아키텍처를 가짐 (엔터프라이즈급 안정성).
- **Runtime:** **Node.js**
- **Database:** **PostgreSQL**
  - *이유:* 관계형 데이터베이스(RDBMS)의 안정성과 JSON 타입 지원을 통한 유연성 확보.
- **ORM:** **Prisma**
  - *이유:* SQL 쿼리 없이 TypeScript 객체 형태로 DB를 조작. 자동완성 지원으로 오타 방지 및 개발 속도 획기적 단축.

### 3.2 Authentication (Google Login)
**OAuth 2.0 + JWT** 방식을 사용합니다.
1.  **Client:** 구글 로그인 버튼 클릭 → 구글 인증 → `Access Token` 획득.
2.  **Server:** 클라이언트로부터 받은 토큰 검증 → 유저 DB 확인(없으면 가입) → **자체 JWT(Access/Refresh)** 발급.
3.  **Client:** JWT를 저장해두고, 게임 저장/랭킹 등록 요청 시 헤더에 실어 보냄.

---

## 4. Database Schema Strategy (Prisma)

**PostgreSQL**을 사용하지만, **Prisma Schema**를 통해 직관적으로 모델링합니다.

### 예상 모델 (Schema.prisma 예시)
* **User:** `id`(UUID), `email`, `nickname`, `googleId`, `createdAt`
* **GameResult:** `id`, `userId`, `clearTime`, `score`, `playedAt` (랭킹용)
* **SaveSlot:** `id`, `userId`, `playerJson`(HP, 골드 등), `inventoryJson`
  * *참고:* 복잡한 게임 상태는 JSON 타입으로 저장하여 스키마 변경 비용을 줄입니다.

---

## 5. Development Pipeline & Collaboration

팀 프로젝트의 효율을 위한 도구 설정입니다.

### 5.1 API Documentation
- **Swagger (NestJS 기본 지원)**
  - Backend 개발자가 API를 만들면 문서가 자동 생성됨.
  - Frontend 개발자는 Swagger UI를 보고 API를 연동 (소통 비용 절감).

### 5.2 Version Control (Git)
- **Repo:** GitHub
- **Strategy:** Feature Branch Workflow
  - `main`: 배포 가능한 안정 버전.
  - `develop`: 개발 중인 기능이 합쳐지는 곳.
  - `feat/login`: 로그인 기능 개발 브랜치.
  - `feat/combat`: 전투 로직 개발 브랜치.

---

## 6. Implementation Roadmap

### Phase 1: 프로토타입 (Frontend 중심)
- `Framer Motion`을 활용한 전투 연출 구현 (타격감, HP바).
- `Zustand` + `Mock Data`를 사용하여 게임 루프(전투↔선택지) 완성.

### Phase 2: 백엔드 기초 & DB 구축
- NestJS 프로젝트 세팅 및 Docker로 PostgreSQL 실행.
- Prisma 스키마 설계 (User, Ranking 테이블).
- Swagger 설정.

### Phase 3: 로그인 & 연동
- 구글 로그인(Passport) 구현.
- Frontend의 `Mock Data`를 실제 API(`GET /game/load`, `POST /game/save`)로 교체.

### Phase 4: 랭킹 & 최적화
- 게임 결과 전송 및 랭킹 산출 로직 구현.
- 보안 점검 (JWT 만료 시간, 비정상 점수 필터링).